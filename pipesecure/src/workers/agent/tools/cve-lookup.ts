import type { DependencyInfo, ScanFinding } from "../types";

const OSV_API = "https://api.osv.dev/v1";
const BATCH_SIZE = 100;

interface OSVQuery {
  package: { name: string; ecosystem: string };
  version: string;
}

interface OSVVulnerability {
  id: string;
  summary: string;
  details: string;
  aliases: string[];
  severity: Array<{ type: string; score: string }>;
  affected: Array<{
    package: { name: string; ecosystem: string };
    ranges: Array<{
      type: string;
      events: Array<{ introduced?: string; fixed?: string }>;
    }>;
  }>;
  database_specific?: Record<string, unknown>;
}

function mapOSVSeverity(vuln: OSVVulnerability): string {
  const cvss = vuln.severity?.find((s) => s.type === "CVSS_V3");
  if (cvss) {
    const score = parseFloat(cvss.score);
    if (score >= 9.0) return "critical";
    if (score >= 7.0) return "high";
    if (score >= 4.0) return "medium";
    return "low";
  }

  const summary = (vuln.summary || "").toLowerCase();
  if (summary.includes("critical") || summary.includes("remote code execution")) return "critical";
  if (summary.includes("arbitrary") || summary.includes("injection")) return "high";
  return "medium";
}

function getFixedVersion(vuln: OSVVulnerability, ecosystem: string): string | null {
  for (const affected of vuln.affected || []) {
    if (affected.package?.ecosystem?.toLowerCase() !== ecosystem.toLowerCase()) continue;
    for (const range of affected.ranges || []) {
      for (const event of range.events || []) {
        if (event.fixed) return event.fixed;
      }
    }
  }
  return null;
}

export async function lookupCVEs(deps: DependencyInfo[]): Promise<ScanFinding[]> {
  const findings: ScanFinding[] = [];

  for (let i = 0; i < deps.length; i += BATCH_SIZE) {
    const batch = deps.slice(i, i + BATCH_SIZE);
    const queries: OSVQuery[] = batch.map((dep) => ({
      package: { name: dep.name, ecosystem: mapEcosystem(dep.ecosystem) },
      version: dep.version,
    }));

    try {
      const response = await fetch(`${OSV_API}/querybatch`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ queries }),
      });

      if (!response.ok) {
        console.warn(`[cve] OSV API returned ${response.status}`);
        continue;
      }

      const data = (await response.json()) as {
        results: Array<{ vulns?: Array<{ id: string }> }>;
      };

      for (let j = 0; j < data.results.length; j++) {
        const result = data.results[j];
        const dep = batch[j];
        if (!result.vulns || result.vulns.length === 0) continue;

        for (const vulnRef of result.vulns) {
          try {
            const vulnResponse = await fetch(`${OSV_API}/vulns/${vulnRef.id}`);
            if (!vulnResponse.ok) continue;

            const vuln = (await vulnResponse.json()) as OSVVulnerability;
            const cveId = vuln.aliases?.find((a: string) => a.startsWith("CVE-")) || vuln.id;
            const fixedVersion = getFixedVersion(vuln, dep.ecosystem);

            findings.push({
              title: `${cveId}: ${vuln.summary || "Known vulnerability"} in ${dep.name}@${dep.version}`,
              description: [
                vuln.details || vuln.summary || "Known vulnerability detected.",
                `\n\n**Affected package:** ${dep.name}@${dep.version}`,
                `**Manifest:** ${dep.manifestFile}`,
                fixedVersion ? `**Fix:** Upgrade to ${dep.name}@${fixedVersion}` : "**Fix:** No fixed version available yet.",
              ].join("\n"),
              severity: mapOSVSeverity(vuln),
              type: "cve",
              filePath: dep.manifestFile,
              cveId,
              tool: "osv",
              ruleId: vuln.id,
              confidence: "high",
              rawData: { vuln, dependency: dep },
            });
          } catch {
            // individual vuln lookup failure
          }
        }
      }
    } catch (error) {
      console.warn("[cve] Batch query failed:", error);
    }
  }

  return findings;
}

function mapEcosystem(ecosystem: string): string {
  const mapping: Record<string, string> = {
    npm: "npm",
    pypi: "PyPI",
    pip: "PyPI",
    go: "Go",
    cargo: "crates.io",
    ruby: "RubyGems",
    maven: "Maven",
    nuget: "NuGet",
    packagist: "Packagist",
  };
  return mapping[ecosystem.toLowerCase()] || ecosystem;
}
